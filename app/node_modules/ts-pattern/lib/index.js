"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
exports.__esModule = true;
exports.match = exports.__ = exports.select = exports.not = exports.when = void 0;
var PatternType_1 = require("./PatternType");
exports.__ = PatternType_1.__;
var when = function (predicate) { return ({
    '@ts-pattern/__patternKind': PatternType_1.PatternType.Guard,
    '@ts-pattern/__when': predicate
}); };
exports.when = when;
var not = function (pattern) { return ({
    '@ts-pattern/__patternKind': PatternType_1.PatternType.Not,
    '@ts-pattern/__pattern': pattern
}); };
exports.not = not;
function select(key) {
    return key === undefined
        ? {
            '@ts-pattern/__patternKind': PatternType_1.PatternType.AnonymousSelect
        }
        : {
            '@ts-pattern/__patternKind': PatternType_1.PatternType.NamedSelect,
            '@ts-pattern/__key': key
        };
}
exports.select = select;
/**
 * #### match
 *
 * Entry point to create a pattern matching expression.
 *
 * It returns a `Match` builder, on which you can chain
 * several `.with(pattern, handler)` clauses.
 */
var match = function (value) {
    return builder(value, []);
};
exports.match = match;
/**
 * ### builder
 * This is the implementation of our pattern matching, using the
 * builder pattern.
 * This builder pattern is neat because we can have complexe type checking
 * for each of the methods adding new behavior to our pattern matching.
 */
var builder = function (value, cases) {
    var run = function () {
        var entry = cases.find(function (_a) {
            var test = _a.test;
            return test(value);
        });
        if (!entry) {
            var displayedValue = void 0;
            try {
                displayedValue = JSON.stringify(value);
            }
            catch (e) {
                displayedValue = value;
            }
            throw new Error("Pattern matching error: no pattern matches value " + displayedValue);
        }
        return entry.handler(entry.select(value), value);
    };
    return {
        "with": function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _a = args.slice(0, -1).reduce(function (acc, arg) {
                if (typeof arg === 'function') {
                    acc.predicates.push(arg);
                }
                else {
                    acc.patterns.push(arg);
                }
                return acc;
            }, { patterns: [], predicates: [] }), patterns = _a.patterns, predicates = _a.predicates;
            var handler = args[args.length - 1];
            var doesMatch = function (value) {
                return Boolean(patterns.some(function (pattern) { return matchPattern(pattern, value); }) &&
                    predicates.every(function (predicate) { return predicate(value); }));
            };
            return builder(value, cases.concat([
                {
                    test: doesMatch,
                    handler: handler,
                    select: function (value) {
                        return patterns.length === 1
                            ? selectWithPattern(patterns[0], value)
                            : value;
                    }
                },
            ]));
        },
        when: function (predicate, handler) {
            return builder(value, cases.concat([
                {
                    test: predicate,
                    handler: handler,
                    select: function (value) { return value; }
                },
            ]));
        },
        otherwise: function (handler) {
            return builder(value, cases.concat([
                {
                    test: function (value) { return true; },
                    handler: handler,
                    select: function (value) { return value; }
                },
            ])).exhaustive();
        },
        exhaustive: function () { return run(); },
        run: run
    };
};
var isObject = function (value) {
    return Boolean(value && typeof value === 'object');
};
var isArray = function (value) { return Array.isArray(value); };
var isGuardPattern = function (x) {
    var pattern = x;
    return (pattern &&
        pattern['@ts-pattern/__patternKind'] === PatternType_1.PatternType.Guard &&
        typeof pattern['@ts-pattern/__when'] === 'function');
};
var isNotPattern = function (x) {
    var pattern = x;
    return pattern && pattern['@ts-pattern/__patternKind'] === PatternType_1.PatternType.Not;
};
var isNamedSelectPattern = function (x) {
    var pattern = x;
    return (pattern && pattern['@ts-pattern/__patternKind'] === PatternType_1.PatternType.NamedSelect);
};
var isAnonymousSelectPattern = function (x) {
    var pattern = x;
    return (pattern &&
        pattern['@ts-pattern/__patternKind'] === PatternType_1.PatternType.AnonymousSelect);
};
var isListPattern = function (x) {
    return Array.isArray(x) && x.length === 1;
};
// tells us if the value matches a given pattern.
var matchPattern = function (pattern, value) {
    if (pattern === PatternType_1.__ ||
        isNamedSelectPattern(pattern) ||
        isAnonymousSelectPattern(pattern))
        return true;
    if (pattern === PatternType_1.__.string)
        return typeof value === 'string';
    if (pattern === PatternType_1.__.boolean)
        return typeof value === 'boolean';
    if (pattern === PatternType_1.__.number) {
        return typeof value === 'number' && !Number.isNaN(value);
    }
    if (isGuardPattern(pattern))
        return Boolean(pattern['@ts-pattern/__when'](value));
    if (isNotPattern(pattern))
        return !matchPattern(pattern['@ts-pattern/__pattern'], value);
    if (isListPattern(pattern))
        return isArray(value)
            ? value.every(function (v) { return matchPattern(pattern[0], v); })
            : false;
    if (typeof pattern !== typeof value)
        return false;
    if (isArray(pattern)) {
        return isArray(value) && pattern.length === value.length
            ? pattern.every(function (subPattern, i) { return matchPattern(subPattern, value[i]); })
            : false;
    }
    if (pattern instanceof Map) {
        if (!(value instanceof Map))
            return false;
        return __spreadArray([], __read(pattern.keys())).every(function (key) {
            return matchPattern(pattern.get(key), value.get(key));
        });
    }
    if (pattern instanceof Set) {
        if (!(value instanceof Set))
            return false;
        var patternValues = __spreadArray([], __read(pattern.values()));
        var allValues_1 = __spreadArray([], __read(value.values()));
        return patternValues.length === 0
            ? allValues_1.length === 0
            : patternValues.length === 1
                ? patternValues.every(function (subPattern) {
                    return Object.values(PatternType_1.__).includes(subPattern)
                        ? matchPattern([subPattern], allValues_1)
                        : value.has(subPattern);
                })
                : patternValues.every(function (subPattern) { return value.has(subPattern); });
    }
    if (isObject(pattern)) {
        if (!isObject(value))
            return false;
        return Object.keys(pattern).every(function (k) {
            // @ts-ignore
            return matchPattern(pattern[k], value[k]);
        });
    }
    return value === pattern;
};
var selectWithPattern = function (pattern, value) {
    var positional = selectPositionalWithPattern(pattern, value);
    var kwargs = selectKwargsWithPattern(pattern, value);
    return positional.kind === 'some'
        ? positional.value
        : Object.keys(kwargs).length
            ? kwargs
            : value;
};
var none = { kind: 'none' };
var selectPositionalWithPattern = function (pattern, value) {
    if (isAnonymousSelectPattern(pattern))
        return { kind: 'some', value: value };
    if (isListPattern(pattern) && isArray(value))
        return value
            .map(function (v) { return selectPositionalWithPattern(pattern[0], v); })
            .filter(function (selection) {
            return selection.kind === 'some';
        })
            .reduce(function (acc, selection) {
            return acc.kind === 'none'
                ? { kind: 'some', value: [selection.value] }
                : { kind: 'some', value: acc.value.concat([selection.value]) };
        }, none);
    if (isArray(pattern) && isArray(value))
        return pattern.length <= value.length
            ? pattern.reduce(function (acc, subPattern, i) {
                if (acc.kind === 'some')
                    return acc;
                return selectPositionalWithPattern(subPattern, value[i]);
            }, none)
            : none;
    if (isObject(pattern) && isObject(value))
        return Object.keys(pattern).reduce(function (acc, k) {
            if (acc.kind === 'some')
                return acc;
            // @ts-ignore
            return selectPositionalWithPattern(pattern[k], value[k]);
        }, none);
    return none;
};
var selectKwargsWithPattern = function (pattern, value) {
    var _a;
    if (isNamedSelectPattern(pattern))
        return _a = {}, _a[pattern['@ts-pattern/__key']] = value, _a;
    if (isListPattern(pattern) && isArray(value))
        return value
            .map(function (v) { return selectKwargsWithPattern(pattern[0], v); })
            .reduce(function (acc, selections) {
            return Object.keys(selections).reduce(function (acc, key) {
                acc[key] = (acc[key] || []).concat([selections[key]]);
                return acc;
            }, acc);
        }, {});
    if (isArray(pattern) && isArray(value))
        return pattern.length <= value.length
            ? pattern.reduce(function (acc, subPattern, i) {
                return Object.assign(acc, selectKwargsWithPattern(subPattern, value[i]));
            }, {})
            : {};
    if (isObject(pattern) && isObject(value))
        return Object.keys(pattern).reduce(function (acc, k) {
            // @ts-ignore
            return Object.assign(acc, selectKwargsWithPattern(pattern[k], value[k]));
        }, {});
    return {};
};
