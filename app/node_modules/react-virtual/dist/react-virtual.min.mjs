import React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];

var rectChanged = function rectChanged(a, b) {
  if (a === void 0) {
    a = {};
  }

  if (b === void 0) {
    b = {};
  }

  return props.some(function (prop) {
    return a[prop] !== b[prop];
  });
};

var observedNodes = /*#__PURE__*/new Map();
var rafId;

var run = function run() {
  var changedStates = [];
  observedNodes.forEach(function (state, node) {
    var newRect = node.getBoundingClientRect();

    if (rectChanged(newRect, state.rect)) {
      state.rect = newRect;
      changedStates.push(state);
    }
  });
  changedStates.forEach(function (state) {
    state.callbacks.forEach(function (cb) {
      return cb(state.rect);
    });
  });
  rafId = window.requestAnimationFrame(run);
};

function observeRect(node, cb) {
  return {
    observe: function observe() {
      var wasEmpty = observedNodes.size === 0;

      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: undefined,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }

      if (wasEmpty) run();
    },
    unobserve: function unobserve() {
      var state = observedNodes.get(node);

      if (state) {
        // Remove the callback
        var index = state.callbacks.indexOf(cb);
        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference

        if (!state.callbacks.length) observedNodes["delete"](node); // Stop the loop

        if (!observedNodes.size) cancelAnimationFrame(rafId);
      }
    }
  };
}

var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;

function useRect(nodeRef, initialRect) {
  if (initialRect === void 0) {
    initialRect = {
      width: 0,
      height: 0
    };
  }

  var _React$useState = React.useState(nodeRef.current),
      element = _React$useState[0],
      setElement = _React$useState[1];

  var _React$useReducer = React.useReducer(rectReducer, initialRect),
      rect = _React$useReducer[0],
      dispatch = _React$useReducer[1];

  var initialRectSet = React.useRef(false);
  useIsomorphicLayoutEffect(function () {
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(function () {
    if (element && !initialRectSet.current) {
      initialRectSet.current = true;

      var _rect = element.getBoundingClientRect();

      dispatch({
        rect: _rect
      });
    }
  }, [element]);
  React.useEffect(function () {
    if (!element) {
      return;
    }

    var observer = observeRect(element, function (rect) {
      dispatch({
        rect: rect
      });
    });
    observer.observe();
    return function () {
      observer.unobserve();
    };
  }, [element]);
  return rect;
}

function rectReducer(state, action) {
  var rect = action.rect;

  if (state.height !== rect.height || state.width !== rect.width) {
    return rect;
  }

  return state;
}

var defaultEstimateSize = function defaultEstimateSize() {
  return 50;
};

var defaultKeyExtractor = function defaultKeyExtractor(index) {
  return index;
};

var defaultMeasureSize = function defaultMeasureSize(el, horizontal) {
  var key = horizontal ? 'offsetWidth' : 'offsetHeight';
  return el[key];
};

var defaultRangeExtractor = function defaultRangeExtractor(range) {
  var start = Math.max(range.start - range.overscan, 0);
  var end = Math.min(range.end + range.overscan, range.size - 1);
  var arr = [];

  for (var i = start; i <= end; i++) {
    arr.push(i);
  }

  return arr;
};
var useElementScroll = function useElementScroll(_ref) {
  var parentRef = _ref.parentRef,
      horizontal = _ref.horizontal,
      useObserver = _ref.useObserver,
      initialRect = _ref.initialRect;
  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';

  var _React$useState = React.useState(0),
      scrollOffset = _React$useState[0],
      setScrollOffset = _React$useState[1];

  var _React$useState2 = React.useState(parentRef.current),
      element = _React$useState2[0],
      setElement = _React$useState2[1];

  useIsomorphicLayoutEffect(function () {
    setElement(parentRef.current);
  });
  useIsomorphicLayoutEffect(function () {
    if (!element) {
      setScrollOffset(0);
      return;
    }

    var onScroll = function onScroll() {
      setScrollOffset(element[scrollKey]);
    };

    onScroll();
    element.addEventListener('scroll', onScroll, {
      capture: false,
      passive: true
    });
    return function () {
      element.removeEventListener('scroll', onScroll);
    };
  }, [element, scrollKey]);
  var scrollToFn = React.useCallback(function (offset) {
    if (parentRef.current) {
      parentRef.current[scrollKey] = offset;
    }
  }, [parentRef, scrollKey]);
  var useMeasureParent = useObserver || useRect;
  var sizeKey = horizontal ? 'width' : 'height';

  var _useMeasureParent = useMeasureParent(parentRef, initialRect),
      outerSize = _useMeasureParent[sizeKey];

  return {
    outerSize: outerSize,
    scrollOffset: scrollOffset,
    scrollToFn: scrollToFn
  };
};

var useWindowRect = function useWindowRect(windowRef, initialRect) {
  if (initialRect === void 0) {
    initialRect = {
      width: 0,
      height: 0
    };
  }

  var _React$useState3 = React.useState(initialRect),
      rect = _React$useState3[0],
      setRect = _React$useState3[1];

  var _React$useState4 = React.useState(windowRef.current),
      element = _React$useState4[0],
      setElement = _React$useState4[1];

  useIsomorphicLayoutEffect(function () {
    setElement(windowRef.current);
  });
  useIsomorphicLayoutEffect(function () {
    if (!element) {
      return;
    }

    function resizeHandler() {
      var next = {
        width: element.innerWidth,
        height: element.innerHeight
      };
      setRect(function (prev) {
        return prev.height !== next.height || prev.width !== next.width ? next : prev;
      });
    }

    resizeHandler();
    element.addEventListener('resize', resizeHandler);
    return function () {
      element.removeEventListener('resize', resizeHandler);
    };
  }, [element]);
  return rect;
};

var useWindowScroll = function useWindowScroll(_ref2) {
  var windowRef = _ref2.windowRef,
      parentRef = _ref2.parentRef,
      horizontal = _ref2.horizontal,
      useWindowObserver = _ref2.useWindowObserver,
      initialRect = _ref2.initialRect;

  var _React$useState5 = React.useState(0),
      scrollOffset = _React$useState5[0],
      setScrollOffset = _React$useState5[1];

  var _React$useState6 = React.useState(windowRef.current),
      element = _React$useState6[0],
      setElement = _React$useState6[1];

  var parentOffsetRef = React.useRef(0);
  var rectKey = horizontal ? 'left' : 'top';
  var scrollKey = horizontal ? 'scrollX' : 'scrollY';
  useIsomorphicLayoutEffect(function () {
    setElement(windowRef.current);
  });
  useIsomorphicLayoutEffect(function () {
    if (!element) {
      parentOffsetRef.current = 0;
      setScrollOffset(0);
      return;
    }

    if (parentRef.current) {
      parentOffsetRef.current = element[scrollKey] + parentRef.current.getBoundingClientRect()[rectKey];
    }

    var onScroll = function onScroll() {
      var offset = element[scrollKey] - parentOffsetRef.current;
      setScrollOffset(offset);
    };

    onScroll();
    element.addEventListener('scroll', onScroll, {
      capture: false,
      passive: true
    });
    return function () {
      element.removeEventListener('scroll', onScroll);
    };
  }, [element, scrollKey, rectKey, parentRef]);
  var scrollToFn = React.useCallback(function (offset, reason) {
    if (windowRef.current) {
      var _windowRef$current$sc;

      var delta = ['ToIndex', 'SizeChanged'].includes(reason) ? parentOffsetRef.current : 0;
      windowRef.current.scrollTo((_windowRef$current$sc = {}, _windowRef$current$sc[rectKey] = offset + delta, _windowRef$current$sc));
    }
  }, [windowRef, rectKey]);
  var useMeasureParent = useWindowObserver || useWindowRect;
  var sizeKey = horizontal ? 'width' : 'height';

  var _useMeasureParent2 = useMeasureParent(windowRef, initialRect),
      outerSize = _useMeasureParent2[sizeKey];

  return {
    outerSize: outerSize,
    scrollOffset: scrollOffset,
    scrollToFn: scrollToFn
  };
};
var useDefaultScroll = function useDefaultScroll(props) {
  var parentRef = props.parentRef,
      windowRef = props.windowRef;
  var useWindow = windowRef !== undefined;
  var emptyRef = React.useRef(null);
  var elementRes = useElementScroll(_extends(_extends({}, props), {}, {
    parentRef: useWindow ? emptyRef : parentRef
  }));
  var windowRes = useWindowScroll(_extends(_extends({}, props), {}, {
    windowRef: useWindow ? windowRef : emptyRef
  }));
  return useWindow ? windowRes : elementRes;
};
function useVirtual(_ref3) {
  var _measurements;

  var _ref3$size = _ref3.size,
      size = _ref3$size === void 0 ? 0 : _ref3$size,
      _ref3$estimateSize = _ref3.estimateSize,
      estimateSize = _ref3$estimateSize === void 0 ? defaultEstimateSize : _ref3$estimateSize,
      _ref3$overscan = _ref3.overscan,
      overscan = _ref3$overscan === void 0 ? 1 : _ref3$overscan,
      _ref3$paddingStart = _ref3.paddingStart,
      paddingStart = _ref3$paddingStart === void 0 ? 0 : _ref3$paddingStart,
      _ref3$paddingEnd = _ref3.paddingEnd,
      paddingEnd = _ref3$paddingEnd === void 0 ? 0 : _ref3$paddingEnd,
      parentRef = _ref3.parentRef,
      windowRef = _ref3.windowRef,
      horizontal = _ref3.horizontal,
      scrollToFn = _ref3.scrollToFn,
      useObserver = _ref3.useObserver,
      useWindowObserver = _ref3.useWindowObserver,
      initialRect = _ref3.initialRect,
      _ref3$keyExtractor = _ref3.keyExtractor,
      keyExtractor = _ref3$keyExtractor === void 0 ? defaultKeyExtractor : _ref3$keyExtractor,
      _ref3$measureSize = _ref3.measureSize,
      measureSize = _ref3$measureSize === void 0 ? defaultMeasureSize : _ref3$measureSize,
      _ref3$rangeExtractor = _ref3.rangeExtractor,
      rangeExtractor = _ref3$rangeExtractor === void 0 ? defaultRangeExtractor : _ref3$rangeExtractor,
      _ref3$useScroll = _ref3.useScroll,
      useScroll = _ref3$useScroll === void 0 ? useDefaultScroll : _ref3$useScroll;
  var latestRef = React.useRef({
    scrollOffset: 0,
    measurements: []
  });

  var _useScroll = useScroll({
    windowRef: windowRef,
    parentRef: parentRef,
    horizontal: horizontal,
    useObserver: useObserver,
    useWindowObserver: useWindowObserver,
    initialRect: initialRect
  }),
      outerSize = _useScroll.outerSize,
      scrollOffset = _useScroll.scrollOffset,
      defaultScrollToFn = _useScroll.scrollToFn;

  var scrollOffsetWithAdjustmentsRef = React.useRef(scrollOffset);

  if (latestRef.current.scrollOffset !== scrollOffset) {
    scrollOffsetWithAdjustmentsRef.current = scrollOffset;
  }

  latestRef.current.outerSize = outerSize;
  latestRef.current.scrollOffset = scrollOffset;
  var scrollTo = React.useCallback(function (offset, reason) {
    var resolvedScrollToFn = scrollToFn || function (offset) {
      return defaultScrollToFn(offset, reason);
    };

    resolvedScrollToFn(offset, defaultScrollToFn);
  }, [scrollToFn, defaultScrollToFn]);

  var _React$useState7 = React.useState({}),
      measuredCache = _React$useState7[0],
      setMeasuredCache = _React$useState7[1];

  var measure = React.useCallback(function () {
    return setMeasuredCache({});
  }, []);
  var pendingMeasuredCacheIndexesRef = React.useRef([]);
  var measurements = React.useMemo(function () {
    var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;
    pendingMeasuredCacheIndexesRef.current = [];
    var measurements = latestRef.current.measurements.slice(0, min);

    for (var i = min; i < size; i++) {
      var key = keyExtractor(i);
      var measuredSize = measuredCache[key];

      var _start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;

      var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);

      var _end = _start + _size;

      measurements[i] = {
        index: i,
        start: _start,
        size: _size,
        end: _end,
        key: key
      };
    }

    return measurements;
  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);
  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || 0) + paddingEnd;
  latestRef.current.measurements = measurements;
  latestRef.current.totalSize = totalSize;

  var _calculateRange = calculateRange(latestRef.current),
      start = _calculateRange.start,
      end = _calculateRange.end;

  var indexes = React.useMemo(function () {
    return rangeExtractor({
      start: start,
      end: end,
      overscan: overscan,
      size: measurements.length
    });
  }, [start, end, overscan, measurements.length, rangeExtractor]);
  var measureSizeRef = React.useRef(measureSize);
  measureSizeRef.current = measureSize;
  var virtualItems = React.useMemo(function () {
    var virtualItems = [];

    var _loop = function _loop(k, len) {
      var i = indexes[k];
      var measurement = measurements[i];

      var item = _extends(_extends({}, measurement), {}, {
        measureRef: function measureRef(el) {
          if (el) {
            var measuredSize = measureSizeRef.current(el, horizontal);

            if (measuredSize !== item.size) {
              var _scrollOffset = latestRef.current.scrollOffset;

              if (item.start < _scrollOffset) {
                var delta = measuredSize - item.size;
                scrollOffsetWithAdjustmentsRef.current += delta;
                defaultScrollToFn(scrollOffsetWithAdjustmentsRef.current, 'SizeChanged');
              }

              pendingMeasuredCacheIndexesRef.current.push(i);
              setMeasuredCache(function (old) {
                var _extends2;

                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));
              });
            }
          }
        }
      });

      virtualItems.push(item);
    };

    for (var k = 0, len = indexes.length; k < len; k++) {
      _loop(k);
    }

    return virtualItems;
  }, [indexes, defaultScrollToFn, horizontal, measurements]);
  var mountedRef = React.useRef(false);
  useIsomorphicLayoutEffect(function () {
    if (mountedRef.current) {
      setMeasuredCache({});
    }

    mountedRef.current = true;
  }, [estimateSize]);
  var scrollToOffset = React.useCallback(function (toOffset, _temp, reason) {
    var _ref4 = _temp === void 0 ? {} : _temp,
        _ref4$align = _ref4.align,
        align = _ref4$align === void 0 ? 'start' : _ref4$align;

    if (reason === void 0) {
      reason = 'ToOffset';
    }

    var _latestRef$current = latestRef.current,
        scrollOffset = _latestRef$current.scrollOffset,
        outerSize = _latestRef$current.outerSize;

    if (align === 'auto') {
      if (toOffset <= scrollOffset) {
        align = 'start';
      } else if (toOffset >= scrollOffset + outerSize) {
        align = 'end';
      } else {
        align = 'start';
      }
    }

    if (align === 'start') {
      scrollTo(toOffset, reason);
    } else if (align === 'end') {
      scrollTo(toOffset - outerSize, reason);
    } else if (align === 'center') {
      scrollTo(toOffset - outerSize / 2, reason);
    }
  }, [scrollTo]);
  var tryScrollToIndex = React.useCallback(function (index, _temp2) {
    var _ref5 = _temp2 === void 0 ? {} : _temp2,
        _ref5$align = _ref5.align,
        align = _ref5$align === void 0 ? 'auto' : _ref5$align,
        rest = _objectWithoutPropertiesLoose(_ref5, ["align"]);

    var _latestRef$current2 = latestRef.current,
        measurements = _latestRef$current2.measurements,
        scrollOffset = _latestRef$current2.scrollOffset,
        outerSize = _latestRef$current2.outerSize;
    var measurement = measurements[Math.max(0, Math.min(index, size - 1))];

    if (!measurement) {
      return;
    }

    if (align === 'auto') {
      if (measurement.end >= scrollOffset + outerSize) {
        align = 'end';
      } else if (measurement.start <= scrollOffset) {
        align = 'start';
      } else {
        return;
      }
    }

    var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;
    scrollToOffset(toOffset, _extends({
      align: align
    }, rest), 'ToIndex');
  }, [scrollToOffset, size]);
  var scrollToIndex = React.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // We do a double request here because of
    // dynamic sizes which can cause offset shift
    // and end up in the wrong spot. Unfortunately,
    // we can't know about those dynamic sizes until
    // we try and render them. So double down!
    tryScrollToIndex.apply(void 0, args);
    requestAnimationFrame(function () {
      tryScrollToIndex.apply(void 0, args);
    });
  }, [tryScrollToIndex]);
  return {
    virtualItems: virtualItems,
    totalSize: totalSize,
    scrollToOffset: scrollToOffset,
    scrollToIndex: scrollToIndex,
    measure: measure
  };
}

var findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {
  while (low <= high) {
    var middle = (low + high) / 2 | 0;
    var currentValue = getCurrentValue(middle);

    if (currentValue < value) {
      low = middle + 1;
    } else if (currentValue > value) {
      high = middle - 1;
    } else {
      return middle;
    }
  }

  if (low > 0) {
    return low - 1;
  } else {
    return 0;
  }
};

function calculateRange(_ref6) {
  var measurements = _ref6.measurements,
      outerSize = _ref6.outerSize,
      scrollOffset = _ref6.scrollOffset;
  var size = measurements.length - 1;

  var getOffset = function getOffset(index) {
    return measurements[index].start;
  };

  var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);
  var end = start;

  while (end < size && measurements[end].end < scrollOffset + outerSize) {
    end++;
  }

  return {
    start: start,
    end: end
  };
}

export { defaultRangeExtractor, useDefaultScroll, useElementScroll, useVirtual, useWindowScroll };
//# sourceMappingURL=react-virtual.min.mjs.map
